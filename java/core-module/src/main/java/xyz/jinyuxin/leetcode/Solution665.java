package xyz.jinyuxin.leetcode;

public class Solution665 {

  //  **
  //   * 665.非递减数列
  //   * 给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。
  //   * <p>
  //   * 我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。
  //   * <p>
  //   * 解题思路：出现a[i]>a[i+1] 要么将a[i+1]变大 要么将a[i]变小，具体改变哪一个得视具体情况而定。
  //   * （1）从下标为1的元素开始判断，如果前后有倒序关系，则计数器加1，没有的话则接着往后面找。
  //   * （2）
  //   * 问能不能将数组变为非递减数组。题目中给的例子太少，不能覆盖所有情况，我们再来看下面三个例子：
  //   * 4，2，3
  //   * -1，4，2，3
  //   * 2，3，3，2，4
  //   * 我们通过分析上面三个例子可以发现，当我们发现后面的数字小于前面的数字产生冲突后，
  //   * [1]有时候需要修改前面较大的数字(比如前两个例子需要修改4)，
  //   * [2]有时候却要修改后面较小的那个数字(比如前第三个例子需要修改2)，
  //   * 那么有什么内在规律吗？是有的，判断修改那个数字其实跟再前面一个数的大小有关系，
  //   * （1）首先如果再前面的数不存在，比如例子1，4前面没有数字了，我们直接修改前面的数字为当前的数字2即可。
  //   * 而当再前面的数字存在，并且小于当前数时，比如例子2，-1小于2，我们还是需要修改前面的数字4为当前数字2；
  //   * （2）如果再前面的数大于当前数，比如例子3，3大于2，我们需要修改当前数2为前面的数3。
  public static boolean judge(int[] nums) {
    if (nums == null || nums.length == 0) {
      return false;
    }

    if (nums.length < 2) {
      return true;
    }

    int len = nums.length;
    int count = 0;
    //从数组第一个元素开始判断,只用判断前后两个元素的关系
    for (int i = 1; i < len; i++) {
      if (nums[i] >= nums[i - 1]) {
        continue;
      }
      //如果找到一个后面的数比我小的
      count++;
      //如果前面两个的数比我大，那就修改我自己，把前面数的值赋值给我
      //比如[2，3，3，2，4] 3赋值给2
      if (i - 2 >= 0 && nums[i - 2] > nums[i]) {
        nums[i] = nums[i - 1];
      } else { //如果前面第二个数不比我大，或者没有数了，那么就修改我前面的数,把我赋值给他。比如[-1，4，2，3] 2赋值给4
        nums[i - 1] = nums[i];
      }

    }

    return count <= 1;
  }

}
